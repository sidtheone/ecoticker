# US-10.2 Implementation Workflow: View Aggregated Feedback

**Date:** 2026-02-13
**Story:** US-10.2 — View aggregated feedback to identify calibration issues
**Persona:** Site Operator
**Branch:** `v2`
**Dependencies:** US-10.1
**Complexity:** S

---

## Current State Analysis

### What Exists

- `score_feedback` table in `src/db/schema.ts` with `topicId`, `dimension`, `direction`, `comment`, `createdAt`.
- Relations: `scoreFeedback` -> `topics`, `scoreFeedback` -> `scoreHistory`.
- Auth: `requireAdminKey()` and `getUnauthorizedResponse()` in `src/lib/auth.ts`.
- Admin layout at `src/app/admin/layout.tsx` (created in US-8.2).
- No admin feedback endpoint or page exists.

### Problems to Solve / Key Design Decisions

1. **Aggregation query**: GROUP BY `topicId`, `dimension`, `direction` with COUNT, joined to `topics` for name. Sort by total reports descending.
2. **Period filtering**: Same pattern as views API (`7d`, `30d`, `all`).
3. **Response shape**: Nested structure per topic -> per dimension -> direction breakdown.
4. **Admin UI**: Simple table page at `/admin/feedback`. Optional but included since the admin layout already exists from US-8.2.

---

## Target State

- `GET /api/admin/feedback?period=7d|30d|all` returns per-topic feedback aggregated by dimension and direction.
- Sorted by most-reported topics first.
- Optional admin page at `/admin/feedback` with a simple table view.

---

## Implementation Phases

### Phase 1: Admin Feedback API (~80 lines)

**File:** `src/app/api/admin/feedback/route.ts`

**Changes:**

1. Create GET handler with period filtering and aggregation:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { scoreFeedback, topics } from "@/db/schema";
import { eq, gte, sql, desc, count } from "drizzle-orm";
import { requireAdminKey, getUnauthorizedResponse } from "@/lib/auth";

export async function GET(request: NextRequest) {
  if (!requireAdminKey(request)) return getUnauthorizedResponse();

  const period = request.nextUrl.searchParams.get("period") || "7d";
  const validPeriods = ["7d", "30d", "all"];
  if (!validPeriods.includes(period)) {
    return NextResponse.json({ error: "Invalid period" }, { status: 400 });
  }

  // Date filter
  let dateFilter;
  if (period !== "all") {
    const days = period === "7d" ? 7 : 30;
    const since = new Date();
    since.setDate(since.getDate() - days);
    dateFilter = gte(scoreFeedback.createdAt, since);
  }

  // Raw aggregation: topic + dimension + direction counts
  const raw = await db
    .select({
      topicId: scoreFeedback.topicId,
      topicName: topics.name,
      topicSlug: topics.slug,
      dimension: scoreFeedback.dimension,
      direction: scoreFeedback.direction,
      count: count(),
    })
    .from(scoreFeedback)
    .innerJoin(topics, eq(scoreFeedback.topicId, topics.id))
    .where(dateFilter)
    .groupBy(scoreFeedback.topicId, topics.name, topics.slug, scoreFeedback.dimension, scoreFeedback.direction)
    .orderBy(desc(count()));

  // Total reports per topic (for sorting)
  const topicTotals = await db
    .select({
      topicId: scoreFeedback.topicId,
      total: count(),
    })
    .from(scoreFeedback)
    .where(dateFilter)
    .groupBy(scoreFeedback.topicId)
    .orderBy(desc(count()));

  // Nest: group raw rows into { topicId, topicName, totalReports, dimensions: { [dim]: { too_high, too_low, reasoning_mismatch, total } } }
  // (nesting done in JS for clarity)
  const topicMap = new Map<number, {
    topicName: string;
    topicSlug: string;
    totalReports: number;
    dimensions: Record<string, Record<string, number>>;
  }>();

  for (const t of topicTotals) {
    topicMap.set(t.topicId, {
      topicName: "",
      topicSlug: "",
      totalReports: Number(t.total),
      dimensions: {},
    });
  }

  for (const row of raw) {
    const entry = topicMap.get(row.topicId);
    if (!entry) continue;
    entry.topicName = row.topicName;
    entry.topicSlug = row.topicSlug;
    if (!entry.dimensions[row.dimension]) {
      entry.dimensions[row.dimension] = { too_high: 0, too_low: 0, reasoning_mismatch: 0, total: 0 };
    }
    entry.dimensions[row.dimension][row.direction] = Number(row.count);
    entry.dimensions[row.dimension].total += Number(row.count);
  }

  // Sort by totalReports descending
  const results = Array.from(topicMap.entries())
    .sort((a, b) => b[1].totalReports - a[1].totalReports)
    .map(([topicId, data]) => ({ topicId, ...data }));

  return NextResponse.json({ period, feedback: results });
}
```

### Phase 2: Admin Feedback Page (~100 lines)

**File:** `src/app/admin/feedback/page.tsx`

**Changes:**

1. Create "use client" page with API key auth (same sessionStorage pattern as analytics page):
```typescript
"use client";

import { useEffect, useState, useCallback } from "react";

type Period = "7d" | "30d" | "all";

interface DimensionBreakdown {
  too_high: number;
  too_low: number;
  reasoning_mismatch: number;
  total: number;
}

interface TopicFeedback {
  topicId: number;
  topicName: string;
  topicSlug: string;
  totalReports: number;
  dimensions: Record<string, DimensionBreakdown>;
}

export default function FeedbackAdminPage() {
  const [apiKey, setApiKey] = useState("");
  const [authenticated, setAuthenticated] = useState(false);
  const [period, setPeriod] = useState<Period>("7d");
  const [data, setData] = useState<TopicFeedback[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    const stored = sessionStorage.getItem("admin_api_key");
    if (stored) { setApiKey(stored); setAuthenticated(true); }
  }, []);

  // ... fetch logic, auth prompt, period toggle, table rendering
  // Table columns: Topic | Dimension | Total | Too High | Too Low | Reasoning Mismatch
}
```

2. Render a flat table expanding each topic's dimensions into rows:
   - Topic Name | Dimension | Total Reports | Too High | Too Low | Reasoning Mismatch
3. Period toggle: 7d / 30d / all (same UI pattern as analytics page).

### Phase 3: Verify & Validate

**Tests to write (~70 lines):**

**File:** `tests/feedback-admin-api.test.ts`

1. GET without API key returns 401.
2. GET with valid key and `period=7d` returns aggregated feedback.
3. GET with invalid period returns 400.
4. Response is sorted by most-reported topic first.
5. Dimension breakdown contains `too_high`, `too_low`, `reasoning_mismatch` counts.

**File:** `tests/FeedbackAdminPage.test.tsx`

6. Renders auth prompt initially.
7. After auth, displays table with feedback data.
8. Period toggle refreshes data.

**Manual verification:**
- Submit several feedback entries via US-10.1.
- Call `GET /api/admin/feedback?period=all` and verify aggregation.
- Visit `/admin/feedback`, verify table renders correctly.

---

## User Journeys

### Journey 1: Site Operator — Identifies calibration issue

1. Operator navigates to `/admin/feedback` and enters API key.
2. Sees table showing "Arctic Ice Melt" has 12 reports, mostly on "ecology" dimension marked "too_high".
3. Realizes the ecology scoring may be overcalibrated for this topic.
4. Decides to review and adjust the LLM prompt or rubric weights.

### Journey 2: Site Operator — Checks feedback via API

1. Operator calls `GET /api/admin/feedback?period=30d` with `X-API-Key`.
2. Receives JSON with per-topic, per-dimension breakdown.
3. Integrates data into an external monitoring tool.

---

## Files Changed Summary

| File | Action | Est. Lines |
|------|--------|------------|
| `src/app/api/admin/feedback/route.ts` | Create | ~80 |
| `src/app/admin/feedback/page.tsx` | Create | ~100 |
| `tests/feedback-admin-api.test.ts` | Create | ~50 |
| `tests/FeedbackAdminPage.test.tsx` | Create | ~50 |
| **Total** | | **~280** |

## Risks

- **Low feedback volume**: If few users submit feedback, aggregation may not be meaningful. This is expected for an MVP -- the infrastructure is in place for when traffic grows.
- **Dimension name inconsistency**: Feedback uses `"ecology"` / `"economy"` while internal code uses `"eco"` / `"econ"`. The admin API returns whatever was stored, which should be the full names from US-10.1.
- **No pagination**: If many topics receive feedback, the response could be large. Acceptable for MVP; add pagination later if needed.

## Definition of Done

- [ ] `GET /api/admin/feedback?period=7d|30d|all` returns per-topic feedback grouped by dimension and direction.
- [ ] Response sorted by most-reported topics first.
- [ ] Each topic shows: name, total reports, per-dimension breakdown (too_high / too_low / reasoning_mismatch).
- [ ] Admin endpoint protected by `requireAdminKey()`.
- [ ] Admin page at `/admin/feedback` displays data in a table.
- [ ] Period toggle (7d / 30d / all) filters data.
- [ ] All new tests pass; existing tests unbroken.
- [ ] TypeScript compiles cleanly; build succeeds.
