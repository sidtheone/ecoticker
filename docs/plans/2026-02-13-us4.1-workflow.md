# US-4.1 Implementation Workflow: Add a New Search Keyword to Track

**Date:** 2026-02-13
**Story:** US-4.1 — Add a search keyword so the system tracks environmental news about it
**Persona:** Alex (Power User) — wants to monitor specific environmental issues
**Branch:** `v2`
**Dependencies:** None
**Complexity:** M

---

## Current State Analysis

### What Exists
- `tracked_keywords` table in `src/db/schema.ts` (lines 136-144): id, keyword (unique), active, status, createdAt, lastSearchedAt, resultCount
- `topics.hidden` column already exists (line 36)
- Batch pipeline (`scripts/batch.ts`) reads keywords from `BATCH_KEYWORDS` env var only (line 23-25)
- Authentication: `requireAdminKey()` + `getUnauthorizedResponse()` in `src/lib/auth.ts`
- Validation: Zod schemas + `validateRequest()` helper in `src/lib/validation.ts`
- Audit logging: `logSuccess()` / `logFailure()` in `src/lib/audit-log.ts`
- No API routes exist for `/api/keywords`
- No admin UI pages exist

### Problems to Solve / Key Design Decisions
1. **Batch pipeline only reads env var** — needs to merge env keywords + DB tracked_keywords (active ones)
2. **No CRUD API for keywords** — need full REST: POST, GET, PATCH, DELETE on `/api/keywords`
3. **Status tracking** — schema already has `status` column (default "pending"). Need to update status in batch pipeline based on results: "pending" -> "active" or "no_results"
4. **Keyword validation** — 2-100 chars, alphanumeric + spaces + hyphens only, unique
5. **Admin UI** — new `/admin/keywords` page (shared with US-4.3 list view)
6. **Dynamic route** — PATCH/DELETE need `/api/keywords/[id]/route.ts` for per-keyword operations

---

## Target State

- `POST /api/keywords` — admin adds a keyword, validated, stored as "pending"
- `GET /api/keywords` — admin lists all keywords (DB + env var system keywords)
- `PATCH /api/keywords/[id]` — admin toggles active status
- `DELETE /api/keywords/[id]` — admin hard-deletes a keyword
- Batch pipeline merges env var keywords + active DB keywords before fetching news
- Batch updates `lastSearchedAt` and `resultCount` on each keyword after search
- After 3+ runs with 0 results, status transitions to "no_results"
- `/admin/keywords` page: table + add form (admin-only)
- All write operations audit-logged

---

## Implementation Phases

### Phase 1: Zod Validation Schemas (~20 lines)

**File:** `src/lib/validation.ts`

**Changes:**
1. Add keyword creation schema:
   ```typescript
   export const keywordCreateSchema = z.object({
     keyword: z.string()
       .min(2, "Keyword must be at least 2 characters")
       .max(100, "Keyword must be at most 100 characters")
       .regex(/^[a-zA-Z0-9\s\-]+$/, "Only letters, numbers, spaces, and hyphens allowed")
       .transform(s => s.trim().toLowerCase()),
   });
   ```

2. Add keyword update schema:
   ```typescript
   export const keywordUpdateSchema = z.object({
     active: z.boolean().optional(),
   });
   ```

### Phase 2: Keywords API Routes (~120 lines)

**File:** `src/app/api/keywords/route.ts` (NEW)

**Changes:**
1. `GET /api/keywords` — list all keywords (admin-only):
   ```typescript
   export async function GET(request: NextRequest) {
     if (!requireAdminKey(request)) return getUnauthorizedResponse();

     const dbKeywords = await db.select().from(trackedKeywords)
       .orderBy(desc(trackedKeywords.createdAt));

     // Include env var keywords as "system" type
     const envKeywords = (process.env.BATCH_KEYWORDS || "").split(",").filter(Boolean);
     const systemKeywords = envKeywords.map((kw, i) => ({
       id: -(i + 1), // negative IDs for system keywords
       keyword: kw.trim(),
       active: true,
       status: "system",
       type: "system",
       createdAt: null,
       lastSearchedAt: null,
       resultCount: null,
     }));

     const userKeywords = dbKeywords.map(kw => ({ ...kw, type: "user" }));
     return NextResponse.json({ keywords: [...systemKeywords, ...userKeywords] });
   }
   ```

2. `POST /api/keywords` — add a keyword (admin-only):
   ```typescript
   export async function POST(request: NextRequest) {
     if (!requireAdminKey(request)) return getUnauthorizedResponse();
     const body = await request.json();
     const validation = validateRequest(keywordCreateSchema, body);
     if (!validation.success) {
       return NextResponse.json({ error: "Validation failed", details: validation.error }, { status: 400 });
     }
     // Check uniqueness (also check env var keywords)
     const envKeywords = (process.env.BATCH_KEYWORDS || "").split(",").map(k => k.trim().toLowerCase());
     if (envKeywords.includes(validation.data.keyword)) {
       return NextResponse.json({ error: "Keyword already exists as a system keyword" }, { status: 409 });
     }
     try {
       const [inserted] = await db.insert(trackedKeywords)
         .values({ keyword: validation.data.keyword, status: "pending" })
         .returning();
       await logSuccess(request, "create_keyword", { keyword: validation.data.keyword });
       return NextResponse.json({ keyword: inserted }, { status: 201 });
     } catch (error) {
       // Unique constraint violation
       if ((error as Error).message?.includes("unique")) {
         return NextResponse.json({ error: "Keyword already exists" }, { status: 409 });
       }
       await logFailure(request, "create_keyword", (error as Error).message);
       return createErrorResponse(error, "Failed to create keyword");
     }
   }
   ```

**File:** `src/app/api/keywords/[id]/route.ts` (NEW)

**Changes:**
3. `PATCH /api/keywords/[id]` — update active status:
   ```typescript
   export async function PATCH(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
     if (!requireAdminKey(request)) return getUnauthorizedResponse();
     const { id } = await params;
     const keywordId = parseInt(id, 10);
     if (isNaN(keywordId)) return NextResponse.json({ error: "Invalid ID" }, { status: 400 });

     const body = await request.json();
     const validation = validateRequest(keywordUpdateSchema, body);
     if (!validation.success) {
       return NextResponse.json({ error: "Validation failed", details: validation.error }, { status: 400 });
     }

     const updates: Record<string, unknown> = {};
     if (validation.data.active !== undefined) {
       updates.active = validation.data.active;
       updates.status = validation.data.active ? "pending" : "inactive";
     }

     const [updated] = await db.update(trackedKeywords)
       .set(updates).where(eq(trackedKeywords.id, keywordId)).returning();
     if (!updated) return NextResponse.json({ error: "Keyword not found" }, { status: 404 });

     await logSuccess(request, "update_keyword", { id: keywordId, changes: updates });
     return NextResponse.json({ keyword: updated });
   }
   ```

4. `DELETE /api/keywords/[id]` — hard delete:
   ```typescript
   export async function DELETE(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
     if (!requireAdminKey(request)) return getUnauthorizedResponse();
     const { id } = await params;
     const keywordId = parseInt(id, 10);
     if (isNaN(keywordId)) return NextResponse.json({ error: "Invalid ID" }, { status: 400 });

     const [deleted] = await db.delete(trackedKeywords)
       .where(eq(trackedKeywords.id, keywordId)).returning();
     if (!deleted) return NextResponse.json({ error: "Keyword not found" }, { status: 404 });

     await logSuccess(request, "delete_keyword", { id: keywordId, keyword: deleted.keyword });
     return NextResponse.json({ success: true, deleted: deleted.keyword });
   }
   ```

### Phase 3: Update Batch Pipeline (~40 lines)

**File:** `scripts/batch.ts`

**Changes:**
1. Import `trackedKeywords` from schema (add to line 7 destructure)

2. Replace hardcoded KEYWORDS with merged keyword loader:
   ```typescript
   async function loadKeywords(): Promise<string[]> {
     // Env var keywords (always included)
     const envKeywords = (process.env.BATCH_KEYWORDS || "").split(",").filter(Boolean).map(k => k.trim());

     // DB tracked keywords (active only)
     const dbRows = await db.select({ id: trackedKeywords.id, keyword: trackedKeywords.keyword })
       .from(trackedKeywords)
       .where(eq(trackedKeywords.active, true));

     const dbKeywordStrings = dbRows.map(r => r.keyword);

     // Merge and deduplicate
     const all = [...new Set([...envKeywords, ...dbKeywordStrings])];
     console.log(`Loaded ${all.length} keywords (${envKeywords.length} env + ${dbKeywordStrings.length} DB)`);
     return all;
   }
   ```

3. After fetching news for each keyword group, update `lastSearchedAt` and `resultCount` on DB keywords:
   ```typescript
   async function updateKeywordStats(keyword: string, articleCount: number): Promise<void> {
     const [row] = await db.select({ id: trackedKeywords.id, resultCount: trackedKeywords.resultCount })
       .from(trackedKeywords).where(eq(trackedKeywords.keyword, keyword.toLowerCase()));
     if (!row) return; // env-var keyword, skip

     const newResultCount = (row.resultCount || 0) + articleCount;
     const newStatus = articleCount > 0 ? "active" :
       (row.resultCount === 0 && newResultCount === 0) ? "no_results" : undefined;

     await db.update(trackedKeywords).set({
       lastSearchedAt: new Date(),
       resultCount: newResultCount,
       ...(newStatus ? { status: newStatus } : {}),
     }).where(eq(trackedKeywords.id, row.id));
   }
   ```

4. In `main()`, replace `KEYWORDS` constant usage with `const keywords = await loadKeywords();`

5. After news fetch loop, call `updateKeywordStats()` for each keyword with its result count

### Phase 4: Admin Keywords Page (~100 lines)

**File:** `src/app/admin/keywords/page.tsx` (NEW)

**Changes:**
1. Server component that fetches keywords from API:
   ```tsx
   "use client";
   import { useState, useEffect } from "react";

   interface Keyword {
     id: number;
     keyword: string;
     active: boolean;
     status: string;
     type: string;
     createdAt: string | null;
     lastSearchedAt: string | null;
     resultCount: number | null;
   }
   ```

2. Add form with input + submit button for new keyword:
   ```tsx
   <form onSubmit={handleAdd} className="flex gap-2 mb-6">
     <input type="text" value={newKeyword} onChange={e => setNewKeyword(e.target.value)}
       placeholder="e.g. coral bleaching" pattern="^[a-zA-Z0-9\s\-]+$"
       className="flex-1 rounded border px-3 py-2 dark:bg-gray-800 dark:border-gray-700" />
     <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
       Add Keyword
     </button>
   </form>
   ```

3. Keywords table with columns: Keyword, Type, Status (badge), Last Searched, Results, Actions (toggle/delete)

4. Status badges with colors:
   - "pending" = yellow
   - "active" = green
   - "no_results" = red
   - "inactive" = gray
   - "system" = blue

5. API key input at top (stored in sessionStorage) for authenticating admin requests

### Phase 5: Tests (~80 lines)

**File:** `tests/keywords-api.test.ts` (NEW)

**Changes:**
1. Mock `@/db` module (same pattern as other API tests)
2. Tests for POST /api/keywords:
   - Creates keyword with valid input (201)
   - Rejects missing keyword (400)
   - Rejects invalid characters (400)
   - Rejects duplicate keyword (409)
   - Rejects unauthenticated request (401)
3. Tests for GET /api/keywords:
   - Returns DB + env var keywords
   - Rejects unauthenticated request (401)
4. Tests for PATCH /api/keywords/[id]:
   - Updates active status
   - Returns 404 for missing keyword
5. Tests for DELETE /api/keywords/[id]:
   - Deletes keyword
   - Returns 404 for missing keyword

**File:** `tests/keywords-validation.test.ts` (NEW)

**Changes:**
1. Unit tests for `keywordCreateSchema`:
   - Valid keyword passes
   - Too short (< 2 chars) fails
   - Too long (> 100 chars) fails
   - Invalid characters fail (e.g., `@#$%`)
   - Trims and lowercases input

### Phase 6: Verify & Validate

1. Run full test suite: `npx jest`
2. TypeScript check: `npx tsc --noEmit`
3. Build check: `npm run build`
4. Manual QA (deferred):
   - Add keyword via admin UI
   - Verify it appears in list with "pending" status
   - Run batch pipeline, verify keyword is included
   - Verify status updates to "active" after results found
   - Test delete and toggle active/inactive
   - Test dark mode on admin page

---

## User Journeys

### Journey 1: Alex (Power User) — Add a New Keyword
1. Navigates to `/admin/keywords`
2. Enters API key in the auth field
3. Types "PFAS contamination" in the add form
4. Clicks "Add Keyword"
5. Sees new row: keyword="pfas contamination", status="pending" (yellow badge)
6. Next batch run picks it up, fetches news, status becomes "active" (green badge)
7. Topics created from those articles appear on the dashboard

### Journey 2: Alex — Keyword Produces No Results
1. Adds keyword "obscure environmental term xyz"
2. After 3+ batch runs, status shows "no_results" (red badge)
3. Alex decides to delete it — clicks Delete, keyword removed

### Journey 3: Admin — View System vs User Keywords
1. Opens `/admin/keywords`
2. Sees system keywords (from BATCH_KEYWORDS env var) marked with blue "system" badge
3. System keywords cannot be edited or deleted (no action buttons)
4. User-added keywords have toggle and delete buttons

---

## Files Changed Summary

| File | Action | Est. Lines |
|------|--------|-----------|
| `src/lib/validation.ts` | MODIFY | +20 |
| `src/app/api/keywords/route.ts` | NEW | +90 |
| `src/app/api/keywords/[id]/route.ts` | NEW | +70 |
| `scripts/batch.ts` | MODIFY | +40 |
| `src/app/admin/keywords/page.tsx` | NEW | +100 |
| `tests/keywords-api.test.ts` | NEW | +80 |
| `tests/keywords-validation.test.ts` | NEW | +30 |
| **Total** | | 7 files, ~+430 |

## Risks
- **Batch keyword count growth** — more keywords = more NewsAPI requests. Mitigation: batch into groups of 4 (existing pattern), warn if total keywords > 20
- **Race condition** — keyword added mid-batch won't be picked up until next run. Acceptable for daily batch.
- **Env var overlap** — user adds keyword that already exists in BATCH_KEYWORDS. Mitigation: check env var keywords on POST, return 409 conflict.
- **Status tracking accuracy** — "no_results" after 3 runs requires tracking run count per keyword. Simplified approach: check `resultCount === 0 && lastSearchedAt !== null` after each run.

## Definition of Done
- [ ] `POST /api/keywords` creates keyword with "pending" status, validates input, checks uniqueness
- [ ] `GET /api/keywords` returns DB keywords + env var system keywords
- [ ] `PATCH /api/keywords/[id]` toggles active status, updates status field
- [ ] `DELETE /api/keywords/[id]` hard-deletes keyword
- [ ] Batch pipeline reads from BOTH env var AND tracked_keywords table
- [ ] Batch updates `lastSearchedAt` and `resultCount` after each run
- [ ] Status transitions: pending -> active (results found), pending -> no_results (3+ runs, 0 results)
- [ ] `/admin/keywords` page with add form, keyword table, status badges, toggle/delete actions
- [ ] All write endpoints require admin API key
- [ ] All write operations audit-logged
- [ ] Validation: 2-100 chars, `^[a-zA-Z0-9\s\-]+$`, unique
- [ ] All existing 224+ tests pass
- [ ] 10+ new tests for API + validation
- [ ] TypeScript compiles with 0 errors
- [ ] Production build succeeds
