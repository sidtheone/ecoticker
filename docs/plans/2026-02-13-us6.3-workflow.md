# US-6.3 Implementation Workflow: Dynamic Social Card Images

**Date:** 2026-02-13
**Story:** US-6.3 — Generate dynamic social card images for topic pages
**Persona:** Social Media User
**Branch:** `v2`
**Dependencies:** US-6.1 (generateMetadata references og:image URL)
**Complexity:** M

---

## Current State Analysis

### What Exists

- US-6.1 (prerequisite) adds `generateMetadata()` in `src/app/topic/[slug]/layout.tsx` with a static fallback `og:image` (`/og-default.png`)
- Topics table has: `name`, `slug`, `currentScore`, `urgency`, `healthScore`, `ecoScore`, `econScore`, `scoreReasoning`
- `urgencyColor()` utility maps urgency levels to color classes (text/bg)
- `scoreToUrgency()` converts numeric score to urgency string
- Recharts is in the project but cannot be used in `ImageResponse` (no DOM in edge runtime)
- Next.js provides `ImageResponse` from `next/og` for generating OG images at the edge
- Score history available via DB query (for sparkline SVG)

### Problems to Solve / Key Design Decisions

1. **Edge runtime:** `ImageResponse` runs in Edge Runtime — cannot use Drizzle/pg connection pool (Node.js only). Decision: fetch topic data via internal API call (`fetch(/api/topics/[slug])`) or use Node.js runtime for the route.
2. **Sparkline rendering:** Recharts uses DOM/Canvas — not available in `ImageResponse`. Decision: render sparkline as inline SVG path using raw `<svg>` + `<polyline>`.
3. **Color mapping:** Need hex colors for `ImageResponse` JSX (not Tailwind classes). Map urgency to hex values.
4. **Cache invalidation:** OG images should regenerate when scores change. Decision: include a score hash in the URL query param so crawlers re-fetch when scores change.
5. **Sub-score bars:** Horizontal bars for health/eco/econ scores rendered as styled `<div>` elements within `ImageResponse` JSX.
6. **Graceful degradation:** If sub-scores are unavailable (all -1), show only overall score.

---

## Target State

- `/api/og/[slug]` returns a 1200x630 PNG image dynamically generated with:
  - Topic name (large)
  - Overall score (large, urgency-colored)
  - Urgency badge
  - Sparkline (SVG polyline)
  - Sub-score horizontal bars (health, eco, econ)
  - EcoTicker branding
- US-6.1's `generateMetadata()` updated to reference `/api/og/[slug]?v={scoreHash}`
- Cached via score hash in URL for automatic invalidation

---

## Implementation Phases

### Phase 1: Create OG Image API Route (~120 lines)

**File:** `src/app/api/og/[slug]/route.tsx` (NEW)

**Changes:**

1. Create the route with Node.js runtime (for DB access):
   ```typescript
   import { ImageResponse } from "next/og";
   import { db } from "@/db";
   import { topics, scoreHistory } from "@/db/schema";
   import { eq, desc } from "drizzle-orm";

   export const runtime = "nodejs";

   const URGENCY_COLORS: Record<string, string> = {
     breaking: "#ef4444",    // red-500
     critical: "#f97316",    // orange-500
     moderate: "#eab308",    // yellow-500
     informational: "#22c55e", // green-500
   };

   const DIMENSION_COLORS = {
     health: "#3b82f6",  // blue-500
     eco: "#22c55e",     // green-500
     econ: "#f59e0b",    // amber-500
   };

   function buildSparklinePath(scores: number[], width: number, height: number): string {
     if (scores.length < 2) return "";
     const step = width / (scores.length - 1);
     const max = Math.max(...scores, 1);
     return scores
       .map((s, i) => `${i * step},${height - (s / max) * height}`)
       .join(" ");
   }

   export async function GET(
     _request: Request,
     { params }: { params: Promise<{ slug: string }> }
   ) {
     const { slug } = await params;

     // Fetch topic data
     const topicRows = await db
       .select({
         name: topics.name,
         currentScore: topics.currentScore,
         urgency: topics.urgency,
         healthScore: topics.healthScore,
         ecoScore: topics.ecoScore,
         econScore: topics.econScore,
       })
       .from(topics)
       .where(eq(topics.slug, slug))
       .limit(1);

     if (topicRows.length === 0) {
       return new Response("Not found", { status: 404 });
     }

     const topic = topicRows[0];
     const scoreColor = URGENCY_COLORS[topic.urgency || "informational"] || "#22c55e";

     // Fetch recent score history for sparkline
     const history = await db
       .select({ score: scoreHistory.score })
       .from(scoreHistory)
       .where(eq(scoreHistory.topicId, /* need topicId */ 0))
       // Actually, we need the topic ID. Adjust query:
       .limit(30);

     // Better approach: join or separate query
     const topicFull = await db
       .select({ id: topics.id })
       .from(topics)
       .where(eq(topics.slug, slug))
       .limit(1);

     const historyRows = topicFull[0]
       ? await db
           .select({ score: scoreHistory.score })
           .from(scoreHistory)
           .where(eq(scoreHistory.topicId, topicFull[0].id))
           .orderBy(desc(scoreHistory.recordedAt))
           .limit(30)
       : [];

     const sparklineScores = historyRows.map((h) => h.score).reverse();
     const sparklinePath = buildSparklinePath(sparklineScores, 300, 60);

     const hasSubScores = topic.healthScore !== null
       && topic.healthScore !== -1
       && topic.ecoScore !== null
       && topic.ecoScore !== -1;

     return new ImageResponse(
       (
         <div
           style={{
             width: 1200,
             height: 630,
             display: "flex",
             flexDirection: "column",
             justifyContent: "space-between",
             padding: 60,
             backgroundColor: "#1a1a2e",
             color: "white",
             fontFamily: "sans-serif",
           }}
         >
           {/* Header */}
           <div style={{ display: "flex", justifyContent: "space-between", alignItems: "flex-start" }}>
             <div style={{ display: "flex", flexDirection: "column", maxWidth: 700 }}>
               <div style={{ fontSize: 42, fontWeight: 700, lineHeight: 1.2 }}>{topic.name}</div>
               <div
                 style={{
                   fontSize: 16,
                   marginTop: 12,
                   padding: "4px 16px",
                   borderRadius: 20,
                   backgroundColor: scoreColor,
                   color: "white",
                   display: "flex",
                   alignSelf: "flex-start",
                 }}
               >
                 {(topic.urgency || "informational").toUpperCase()}
               </div>
             </div>
             <div style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
               <div style={{ fontSize: 96, fontWeight: 800, color: scoreColor, lineHeight: 1 }}>
                 {topic.currentScore}
               </div>
               <div style={{ fontSize: 16, color: "#9ca3af", marginTop: 4 }}>Impact Score</div>
             </div>
           </div>

           {/* Middle: Sub-score bars OR sparkline */}
           <div style={{ display: "flex", gap: 40, alignItems: "flex-end" }}>
             {/* Sub-score bars */}
             {hasSubScores && (
               <div style={{ display: "flex", flexDirection: "column", gap: 12, flex: 1 }}>
                 {([
                   { label: "Health", score: topic.healthScore || 0, color: DIMENSION_COLORS.health },
                   { label: "Ecological", score: topic.ecoScore || 0, color: DIMENSION_COLORS.eco },
                   { label: "Economic", score: topic.econScore || 0, color: DIMENSION_COLORS.econ },
                 ]).map((dim) => (
                   <div key={dim.label} style={{ display: "flex", alignItems: "center", gap: 12 }}>
                     <div style={{ width: 90, fontSize: 14, color: "#9ca3af" }}>{dim.label}</div>
                     <div style={{ flex: 1, height: 16, backgroundColor: "#374151", borderRadius: 8, overflow: "hidden", display: "flex" }}>
                       <div style={{ width: `${dim.score}%`, height: "100%", backgroundColor: dim.color, borderRadius: 8 }} />
                     </div>
                     <div style={{ width: 30, fontSize: 14, color: "#d1d5db", textAlign: "right" }}>{dim.score}</div>
                   </div>
                 ))}
               </div>
             )}

             {/* Sparkline */}
             {sparklinePath && (
               <div style={{ display: "flex", width: 320 }}>
                 <svg width="300" height="60" viewBox="0 0 300 60">
                   <polyline
                     points={sparklinePath}
                     fill="none"
                     stroke={scoreColor}
                     strokeWidth="2.5"
                     strokeLinecap="round"
                     strokeLinejoin="round"
                   />
                 </svg>
               </div>
             )}
           </div>

           {/* Footer */}
           <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
             <div style={{ fontSize: 20, fontWeight: 600, color: "#6ee7b7" }}>EcoTicker</div>
             <div style={{ fontSize: 14, color: "#6b7280" }}>Environmental Impact Tracker</div>
           </div>
         </div>
       ),
       {
         width: 1200,
         height: 630,
       }
     );
   }
   ```

### Phase 2: Update generateMetadata to Use Dynamic OG Image (~10 lines)

**File:** `src/app/topic/[slug]/layout.tsx`

**Changes:**

1. Replace static `/og-default.png` with dynamic OG image URL:
   ```typescript
   const scoreHash = topic.currentScore; // Simple version: score as cache-buster
   const ogImageUrl = `${baseUrl}/api/og/${slug}?v=${scoreHash}`;

   return {
     // ...
     openGraph: {
       // ...
       images: [{ url: ogImageUrl, width: 1200, height: 630, alt: topic.name }],
     },
     twitter: {
       // ...
       images: [ogImageUrl],
     },
   };
   ```

2. Keep static fallback for topics that fail to load:
   ```typescript
   if (rows.length === 0) {
     return {
       title: "Topic Not Found — EcoTicker",
       openGraph: { images: ["/og-default.png"] },
     };
   }
   ```

### Phase 3: Add Tests (~45 lines)

**File:** `tests/api-og.test.ts` (NEW)

**Changes:**

1. Test: "returns 200 with image/png content type for valid slug"
2. Test: "returns 404 for non-existent slug"
3. Test: "includes topic name in image generation" (verify the handler is called with correct data)
4. Test: "handles topics without sub-scores gracefully"
5. Test: "builds sparkline path correctly from score history"
   ```typescript
   // Unit test for buildSparklinePath (extract to shared util or test inline)
   it("builds sparkline path from scores", () => {
     const path = buildSparklinePath([50, 60, 40, 70], 300, 60);
     expect(path).toContain("0,");    // starts at x=0
     expect(path).toContain("300,");  // ends at x=300
   });
   ```

### Phase 4: Verify & Validate

1. `npx tsc --noEmit` — no type errors
2. `npx jest` — full suite passes
3. Open `/api/og/some-slug` in browser — verify PNG image renders
4. Check image dimensions: 1200x630
5. Verify topic name, score, urgency badge, sparkline, sub-score bars visible
6. Test with a topic that has no sub-scores — verify graceful degradation
7. Test OG image in Twitter Card Validator / Facebook Sharing Debugger

---

## User Journeys

### Journey 1: Social Media User — Sharing generates attractive preview

1. User copies a topic URL from EcoTicker
2. Pastes into Twitter/X compose box
3. Twitter fetches `og:image` URL: `/api/og/amazon-deforestation?v=72`
4. EcoTicker generates a dynamic 1200x630 PNG showing:
   - "Amazon Deforestation" (large title)
   - Score "72" in orange (critical)
   - "CRITICAL" urgency badge
   - Sparkline showing recent score trend
   - Health/Eco/Econ sub-score bars
   - "EcoTicker" branding
5. Preview card appears in the tweet, visually communicating the severity

### Journey 2: Social Media User — Score changes regenerate image

1. Topic score changes from 72 to 85 (now "breaking")
2. User shares the same topic URL
3. `og:image` URL now has `?v=85` — different from cached `?v=72`
4. Social platform fetches the new image with updated score and red color
5. Preview accurately reflects current severity

---

## Files Changed Summary

| File | Action | Est. Lines |
|------|--------|------------|
| `src/app/api/og/[slug]/route.tsx` | Create | +120 |
| `src/app/topic/[slug]/layout.tsx` | Modify | +10 |
| `tests/api-og.test.ts` | Create | +45 |

**Total estimated:** ~175 lines changed

## Risks

- **ImageResponse JSX limitations:** `next/og` uses Satori under the hood, which supports a subset of CSS (flexbox only, no grid). All layout must use `display: flex`. Verified: the design above uses only flexbox.
- **SVG in ImageResponse:** Satori supports basic SVG elements (`<svg>`, `<polyline>`, `<path>`). The sparkline approach (polyline with points) is compatible.
- **Font rendering:** Satori uses a default sans-serif font. Custom fonts can be loaded but add complexity. Decision: use default font for MVP.
- **Performance:** Each OG image request triggers 2 DB queries (topic + history). Mitigated: queries are lightweight (indexed slug, LIMIT 30). Social platforms cache images aggressively.
- **Node.js runtime:** Using `runtime = "nodejs"` instead of edge for DB access. This means the route runs in the Node.js serverless function, not at the edge. Acceptable for OG images (not latency-critical).

## Definition of Done

- [ ] `/api/og/[slug]` returns a 1200x630 PNG image
- [ ] Image shows: topic name, score (colored), urgency badge, sparkline, sub-score bars
- [ ] Returns 404 for non-existent slugs
- [ ] Graceful degradation: omits sub-score bars if scores unavailable
- [ ] US-6.1's `generateMetadata()` updated to reference dynamic OG image
- [ ] Score hash in URL enables cache invalidation on score changes
- [ ] All new and existing tests pass
- [ ] TypeScript compiles without errors
