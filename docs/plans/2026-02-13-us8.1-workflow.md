# US-8.1 Implementation Workflow: Track Page Views Per Topic

**Date:** 2026-02-13
**Story:** US-8.1 — Track page views per topic
**Persona:** Site Operator
**Branch:** `v2`
**Dependencies:** None
**Complexity:** S

---

## Current State Analysis

### What Exists

- `topic_views` table already defined in `src/db/schema.ts` with columns: `id`, `topicId` (FK to topics), `date`, `viewCount` (default 0), plus a unique index on `(topicId, date)`.
- `topicViewsRelations` defined linking back to `topics`.
- Topic detail page at `src/app/topic/[slug]/page.tsx` ("use client") fetches topic data on mount but does **not** track views.
- No `src/app/api/views/` directory or route exists yet.
- No admin views endpoint exists.

### Problems to Solve / Key Design Decisions

1. **Fire-and-forget POST** from the client: Must not block page render or show errors to the user. Use `fetch(...).catch(() => {})` pattern.
2. **Upsert logic**: Use Drizzle's `onConflictDoUpdate` on the unique `(topicId, date)` index to increment `view_count` atomically via `sql\`view_count + 1\``.
3. **Slug-to-ID resolution**: The POST endpoint receives a slug; must look up `topics.id` first.
4. **No user identification**: No cookies, no fingerprinting, no raw IP stored. Just aggregate counts per topic per day.
5. **Admin views endpoint**: Protected by `requireAdminKey()`, supports `period` query param to filter by date range.
6. **Rate limiting**: Use `writeLimiter` for POST (10/min per IP) to prevent abuse. Use `readLimiter` for admin GET.

---

## Target State

- Topic detail page fires a fire-and-forget `POST /api/views/[slug]` on mount.
- API route upserts `view_count` for today's date + resolved `topic_id`.
- Admin API `GET /api/admin/views?period=7d|30d|all` returns topic view counts sorted descending.
- No user identification stored anywhere.

---

## Implementation Phases

### Phase 1: Public View Tracking API (~50 lines)

**File:** `src/app/api/views/[slug]/route.ts`

**Changes:**

1. Create the POST handler:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { topics, topicViews } from "@/db/schema";
import { eq, sql } from "drizzle-orm";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ slug: string }> }
) {
  try {
    const { slug } = await params;

    // Resolve slug to topic ID
    const topic = await db
      .select({ id: topics.id })
      .from(topics)
      .where(eq(topics.slug, slug))
      .limit(1);

    if (topic.length === 0) {
      return NextResponse.json({ error: "Topic not found" }, { status: 404 });
    }

    const topicId = topic[0].id;
    const today = new Date().toISOString().split("T")[0]; // YYYY-MM-DD

    // Upsert: increment view_count for today
    await db
      .insert(topicViews)
      .values({ topicId, date: today, viewCount: 1 })
      .onConflictDoUpdate({
        target: [topicViews.topicId, topicViews.date],
        set: { viewCount: sql`${topicViews.viewCount} + 1` },
      });

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
```

### Phase 2: Admin Views API (~70 lines)

**File:** `src/app/api/admin/views/route.ts`

**Changes:**

1. Create GET handler with period filtering:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { topics, topicViews } from "@/db/schema";
import { eq, gte, sql, desc } from "drizzle-orm";
import { requireAdminKey, getUnauthorizedResponse } from "@/lib/auth";

export async function GET(request: NextRequest) {
  if (!requireAdminKey(request)) return getUnauthorizedResponse();

  const period = request.nextUrl.searchParams.get("period") || "7d";
  const validPeriods = ["7d", "30d", "all"];
  if (!validPeriods.includes(period)) {
    return NextResponse.json(
      { error: "Invalid period. Use: 7d, 30d, all" },
      { status: 400 }
    );
  }

  // Build date filter
  const conditions = [];
  if (period !== "all") {
    const days = period === "7d" ? 7 : 30;
    const since = new Date();
    since.setDate(since.getDate() - days);
    conditions.push(gte(topicViews.date, since.toISOString().split("T")[0]));
  }

  // Aggregate views per topic
  const results = await db
    .select({
      topicId: topicViews.topicId,
      topicName: topics.name,
      topicSlug: topics.slug,
      totalViews: sql<number>`SUM(${topicViews.viewCount})`.as("total_views"),
    })
    .from(topicViews)
    .innerJoin(topics, eq(topicViews.topicId, topics.id))
    .where(conditions.length > 0 ? conditions[0] : undefined)
    .groupBy(topicViews.topicId, topics.name, topics.slug)
    .orderBy(desc(sql`total_views`));

  // Daily totals for chart data
  const dailyTotals = await db
    .select({
      date: topicViews.date,
      totalViews: sql<number>`SUM(${topicViews.viewCount})`.as("total_views"),
    })
    .from(topicViews)
    .where(conditions.length > 0 ? conditions[0] : undefined)
    .groupBy(topicViews.date)
    .orderBy(topicViews.date);

  return NextResponse.json({ period, topics: results, dailyTotals });
}
```

### Phase 3: Fire-and-Forget Client Call (~5 lines)

**File:** `src/app/topic/[slug]/page.tsx`

**Changes:**

1. Add a `useEffect` after the existing data fetch to fire the view tracking call:
```typescript
// Track page view (fire-and-forget)
useEffect(() => {
  if (slug) {
    fetch(`/api/views/${slug}`, { method: "POST" }).catch(() => {});
  }
}, [slug]);
```

This goes inside the `TopicDetailPage` component, after the existing `useEffect` blocks (around line 81).

### Phase 4: Verify & Validate

**Tests to write (~80 lines):**

**File:** `tests/views-api.test.ts`

1. POST `/api/views/[slug]` returns `{ ok: true }` and upserts view count.
2. POST `/api/views/nonexistent` returns 404.
3. GET `/api/admin/views?period=7d` returns aggregated data (requires API key).
4. GET `/api/admin/views` without API key returns 401.
5. GET `/api/admin/views?period=invalid` returns 400.

**File:** `tests/TopicDetailPage.test.tsx`

6. Verify that `fetch` is called with `POST /api/views/[slug]` on mount.

**Manual verification:**
- Visit a topic detail page, check `topic_views` table has a new row.
- Call admin endpoint with API key, verify aggregated response.

---

## User Journeys

### Journey 1: Visitor — Views a topic

1. Visitor navigates to `/topic/amazon-deforestation`.
2. Page loads and renders topic detail with sub-scores.
3. In the background, a fire-and-forget POST to `/api/views/amazon-deforestation` fires.
4. The API resolves the slug, upserts today's view count. Visitor sees nothing.

### Journey 2: Site Operator — Checks popular topics

1. Operator calls `GET /api/admin/views?period=30d` with `X-API-Key` header.
2. Receives JSON with topics sorted by total views and daily totals.
3. Uses data to understand which environmental topics attract the most attention.

---

## Files Changed Summary

| File | Action | Est. Lines |
|------|--------|------------|
| `src/app/api/views/[slug]/route.ts` | Create | ~50 |
| `src/app/api/admin/views/route.ts` | Create | ~70 |
| `src/app/topic/[slug]/page.tsx` | Modify | ~5 |
| `tests/views-api.test.ts` | Create | ~80 |
| `tests/TopicDetailPage.test.tsx` | Modify | ~10 |
| **Total** | | **~215** |

## Risks

- **Bot traffic inflating views**: No bot protection. Acceptable for MVP; can add basic User-Agent filtering later.
- **Race conditions on upsert**: PostgreSQL's `ON CONFLICT DO UPDATE` with `view_count + 1` is atomic, so no risk.
- **Double-counting on re-renders**: React StrictMode in dev fires effects twice. Production only fires once. Acceptable.

## Definition of Done

- [ ] `POST /api/views/[slug]` upserts view count for today's date + topic.
- [ ] Topic detail page fires the POST on mount (fire-and-forget, no UI impact).
- [ ] `GET /api/admin/views?period=7d|30d|all` returns topic view counts sorted descending.
- [ ] Admin endpoint protected by `requireAdminKey()`.
- [ ] No user identification stored (no IP, no cookies, no fingerprint).
- [ ] All new tests pass; existing 224 tests unbroken.
- [ ] TypeScript compiles cleanly; build succeeds.
